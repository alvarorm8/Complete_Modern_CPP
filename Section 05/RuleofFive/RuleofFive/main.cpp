#include "Integer.h"
class Number{
	Integer m_Value{} ;
public:
	Number()=default ;
	Number(int value):m_Value{value}{
	}
	/*Number(const Number &n):m_Value{n.m_Value}{
	}*/
	/*~Number(){
	}*/
	Number(Number &&n) = default ;
	Number(const Number &n) = default ;
	Number & operator=(Number&&)=default ;
	Number & operator=(const Number&)=default ;
};
Number CreateNumber(int num){
	Number n{num} ;
	return n ;
}

Integer Add(int a, int b) {
	Integer temp(a + b);
	return temp;
}

void Print(Integer obj){}

int main(){
	/*
	If we only define the parametrized constructor in Number, at auto n2{n1} the compiler will call the copy constructor of Number, which
	is autogenerated by the compiler and, internally, it will call the copy constructor of Integer.

	The same for n2 = n1, it will call the copy assignment operator.
	*/
	Number n1 ;
	auto n2{n1} ;
	n2 = n1 ;

	/*
	If we only define the parametrized constructor in Number, at auto n2{n1} the compiler will call the move constructor of Number, which
	is autogenerated by the compiler and, internally, it will call the move constructor of Integer.

	The same for n2 = n1, it will call the move assignment operator.
	*/
	auto n3{CreateNumber(3)};
	n3 = CreateNumber(3);

	/*
	If we provide an implementation for copy constructor, for example, move constructor and move assignment operator will not be synthesized.
	It will call always the copy constructor or the copy assignment operator.

	If we provide an implementation for move constructor, copy constructor, copy assignment operator and move assignment operator will not be synthesized and the 
	compilation will fail (if we provide move assignment operator, the move constructor, copy constructor and copy assignment operator will not be synthesized).

	If you provide a definition for any operation or constructor and you don't want to define the others, you can use the default operators so the compiler synthesized them.
	But you have to explicitly write them.

	It's synthesized in the PowerPoint slide 93, when it says default, it means it synthesized without writing anything.
	*/

	Integer n4 = 6;
	/*
	As I am assigning a number to a class, which are not compatible, this expands to Integer n4 = Integer(6).
	It creates a temporary object and then assigns it with copy assignment operator or move assignment operator.
	In modern compilers the Copy Elision or Move Elision is automatically done. With it, the process is improved 
	by avoiding the temporary object and simply expanding the expression to Integer n4(6).

	We can turn off this funcionality when compiling with gcc with the flag -fno-elide-constructors. With this, the copy or move
	constructor will be called depending on the necessity.
	*/

	Integer n5 = Add(8, 9);

	/*
	In this case, if elision is turned off, there will be 3 calls to move constructor. First, the object temp is created with the parametrized constructor, 
	later, the move constructor is called to return temp as a temporary, and lastly, the move constructor is called to assign n5 to that temporary.

	If elision is turned on, only the parametrized constructor is called to create temp, the calls to move constructors is avoided, and even the move constructor
	is avoided to assign that temporary to n5. This is known as Named return value optimization.

	If we compile in debug mode instead of release mode, the move constructor to assign to n5 is not elided.

	A better implementation would be

	Integer Add(int a, int b) {
		return Integer (a + b);
	}

	*/
	Integer a(1);

	//auto b(a); //calls to copy constructor
	//auto c(static_cast<Integer&&>(a)); //calls to move constructor, but is not clear what I want to do
	//auto d(std::move(a)); //forces the compiler to call to move constructor instead of copy. It is clearer what I want to do.

	Print(std::move(a));
	/*
	Calls to print moving the resources from a to the temporary object in the function, so when the function ends, the object is
	destroyed and we don't have to free resources from a. After that call to Print, we can't access a members, we have to reassign them
	*/

	a.SetValue(20);
	
	//Another use of std::move is with classes that can not be copied (don't have copy constructor)
	//If we use std::move on classes with no resources (pointers, etc.) it will do nothing, it will copy the object.
	
}
